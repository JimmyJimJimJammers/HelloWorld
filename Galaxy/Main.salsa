module Galaxy;

import java.io.*;
import java.util.*;

/* Analyzer.salsa -- Parallel distance calculation rules
 *
 * Input: 
 *    1.  starsFile.txt, a stars text file with the first line giving the total number of stars in the file 
 *        followed by one line per star representing each star's three dimensions <x,y,z> as X Y Z. 
 *    2.  n, number of Actresses.
 *    3.  serverName, the name server
 *    4.  theatersFile.txt, a file containing theater locations
 *
 * Output:  
 *    1.  Closest neighbours, the set of pairs of stars that minimize pairwise distance.
 *    2.  Farthest neighbours, the set of pairs of stars that maximize pairwise distance.
 *    3.  Ideal hub stars, the set of stars which minimize the maximal distance to any other star.
 *    4.  Ideal jail stars, the set of stars which maximize the minimal distance to any other star.
 *    5.  Ideal capital stars, the set of stars which minimize the average distance to all other stars.
 *
 * Algorithm:
 *    1.  
 *    2.  
 *    3a. 
 *    3b. 
 *
 * Note:  
 *
 */

behavior Main 
{
	String starsFile = "test.txt";    // Stars file
	long startTime = 0;                 // Starting Time
	String serverName = "localhost";  // Name Server
	String theatersFile = "theatersFile.txt";    // File containing the theaters          
	String newFile = "newFile.txt";
	int numStar;                        // number of different stars


	// Change these into map form
	// use strings for keys 
	int xIndex = 0;
    int yIndex = 1;
    int zIndex = 2;
    int minIndex = 3;
    int maxIndex = 4;
    int xMinIndex = 5;
    int yMinIndex = 6;
    int zMinIndex = 7;
    int xMaxIndex = 8;
    int yMaxIndex = 9;
    int zMaxIndex = 10;
    int avgIndex = 11;
    int numStarIndex = 12; // used to encode the result of one actor with an array of doubles

	void act(String [] argv)
	{
			
		if (argv[argv.length-1].equalsIgnoreCase("-c"))
		{
			standardOutput<-print("WE Made it!");
			starsFile = argv[0];
            removeDuplicates()@SendtoActressesC();
		}
		else 
		{
			if (argv.length == 3) 
			{
				starsFile = argv[0];
				serverName = argv[1];
				theatersFile = argv[2];
			}
			removeDuplicates()@SendtoActresses();
		}
	}


	/** Deduplicate the stars file, return the name of the deduplicated file */
	void removeDuplicates()
	{

		TreeSet starSet = new TreeSet();
		try 
		{

			BufferedReader bufferedReader = new BufferedReader(new FileReader(starsFile));
			String tempStar;
            tempStar = bufferedReader.readLine();

			while ((tempStar = bufferedReader.readLine()) != null) 
				if (!tempStar.equalsIgnoreCase("")) 
					starSet.add(tempStar);
			bufferedReader.close();
		} 
		catch (IOException ioe) 
		{
			standardOutput<-print("File Error: " + starsFile + "\n");
		}

		try 
		{
			PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(newFile)));
			Iterator itr = starSet.iterator(); 
			while(itr.hasNext()) 
				writer.println((String)itr.next());
			writer.close();
		} 
		catch (IOException ioe) 
		{
			standardOutput<-print("File Error: " + newFile + "\n");
		}
		numStar = starSet.size();
	}

	/** Distribute to the Actresses based on the deduplicated stars file for distributed computation */
	void SendtoActresses() {

		//create Actresses and assign data
		Actress[] Actresses = new Actress[numStar];
		ArrayList theaters = new ArrayList();
		String theater;
		int i = 0;
		while( i < numStar)
		{                                   	// first create actresses
			Actresses[i] = new Actress();
			i++;
		}


		try {															// try to find theaters
			BufferedReader bufferedReader = new BufferedReader(new FileReader(theatersFile));
			while ((theater = bufferedReader.readLine()) != null) {
				theaters.add(theater);
			}
			bufferedReader.close(); 
		} catch (IOException ioe){
			standardOutput<-println("File Error: " + theatersFile);
		}

		// migrate Actresses to theaters
		int looper = 0;                                    // ************************COME BACK TO HERE *********************
		int x = 0;
		while (looper < numStar)
		{
			if (x == theaters.size())
				x = 0;
			standardOutput<-print("Sending Actress uan://" + serverName + ":3030/a"+ x +" to rmsp://" +theaters.get(x)+"/a"+x + "\n");

			Actresses[x] = new Actress() at  (new UAN("uan://"+serverName+":3030/a"+x), new UAL("rmsp://"+theaters.get(x)+"/a"+x));
			x++;
		}
		
		standardOutput<-print("Program Start: \n");
		startTime = System.currentTimeMillis();
		
		//start computation using join method
		join 
		{
			int t =0;
			while(t < numStar)
			 {
				Actresses[t]<-calc(t, newFile, numStar);
				t++;
			}
		}@compareData(token);
	}

	//Concurrent version
	void SendtoActressesC() {

		//create Actresses and assign data
		Actress[] Actresses = new Actress[numStar];
		int t =0;
		while (t < numStar)
		{                                
			Actresses[t] = new Actress();
			t++;
		}

		
		startTime = System.currentTimeMillis();
		standardOutput<-print("Program Start: \n");	

		join 																// Starting the computation
		{
			int x = 0;
			while(x < numStar)
			{
				Actresses[x]<-calc(x, newFile, numStar);
				x++;
			}
		}@compareData(token);
	}

	void endTimer(){
		long endTime = System.currentTimeMillis();
		long result = endTime - startTime;
		standardOutput<-print("Total time: " + result +" ms.\n");
	}

    //takes the results from the Actresses and combines them
	void compareData(Object[] results)
    {
        //closest neighbours
		double closestNeighborDist = Double.MAX_VALUE;
        //farthest neighbours
        double farthestNeighborDist = 0.0;
        //minimum max distance **
        double minmaxdis = Double.MAX_VALUE;
        //maximum min distance **
        double maxmindis = 0.0;
        // minimum average distance
        double minavgdis = Double.MAX_VALUE;

        //for holding the each star and it's closest neighbor
		ArrayList[] closestNeighbor = new ArrayList[6];             //pair
        // farthest neighbour pairs
        ArrayList[] farthestNeighbor = new ArrayList[6];            //pair
        //ideal hub stars
        ArrayList[] idealHubStar = new ArrayList[6];                //single
        // ideal jail stars
        ArrayList[] idealJailStar = new ArrayList[6];               //single
        // ideal capital stars
        ArrayList[] idealCapitalStar = new ArrayList[3];            //single

        //go through and make an ArrayList for each coordinate?
		for (int i = 0; i < 6; i++)
        {
            closestNeighbor[i] = new ArrayList();
            farthestNeighbor[i] = new ArrayList();
            idealHubStar[i] = new ArrayList();
            idealJailStar[i] = new ArrayList();

            if(i < 3)
            {
                idealCapitalStar[i] = new ArrayList();
            }

        }

		//standardOutput<-println("summing...");
		for (int i = 0; i < numStar; i++)
        {
            //if the closest neighbors for this pair is closer, update the value
			if ((Double)((ArrayList)results[i]).get(minIndex) <= closestNeighborDist)
            {
                standardOutput<-print("Closest Dist: " + (Double)((ArrayList)results[i]).get(minIndex) + " <= " + closestNeighborDist + "\n");
                if((Double)((ArrayList)results[i]).get(minIndex) < closestNeighborDist)
                {
                    standardOutput<-print("Clearing\n");
                    for (int j = 0; j < 6; j++)
                    {
                        closestNeighbor[j].clear();
                    }
                }

				closestNeighborDist = (Double)((ArrayList)results[i]).get(minIndex);
				closestNeighbor[0].add((Double)((ArrayList)results[i]).get(xIndex));
				closestNeighbor[1].add((Double)((ArrayList)results[i]).get(yIndex));
				closestNeighbor[2].add((Double)((ArrayList)results[i]).get(zIndex));
				closestNeighbor[3].add((Double)((ArrayList)results[i]).get(xMinIndex));
				closestNeighbor[4].add((Double)((ArrayList)results[i]).get(yMinIndex));
				closestNeighbor[5].add((Double)((ArrayList)results[i]).get(zMinIndex));
			}

			if ((Double)((ArrayList)results[i]).get(maxIndex) >= farthestNeighborDist)
            {
                standardOutput<-print("\tFarthest Dist: " + (Double)((ArrayList)results[i]).get(maxIndex) + " >= " + farthestNeighborDist + "\n");
                if((Double)((ArrayList)results[i]).get(maxIndex) > farthestNeighborDist)
                {
                    standardOutput<-print("\tClearing\n");
                    for (int j = 0; j < 6; j++)
                    {
                        farthestNeighbor[j].clear();
                    }
                }

				farthestNeighborDist = (Double)((ArrayList)results[i]).get(maxIndex);
				farthestNeighbor[0].add((Double)((ArrayList)results[i]).get(xIndex));
				farthestNeighbor[1].add((Double)((ArrayList)results[i]).get(yIndex));
				farthestNeighbor[2].add((Double)((ArrayList)results[i]).get(zIndex));
				farthestNeighbor[3].add((Double)((ArrayList)results[i]).get(xMaxIndex));
				farthestNeighbor[4].add((Double)((ArrayList)results[i]).get(yMaxIndex));
				farthestNeighbor[5].add((Double)((ArrayList)results[i]).get(zMaxIndex));
			}

			if ((Double)((ArrayList)results[i]).get(maxIndex) <= minmaxdis)
            {
                standardOutput<-print("\t\tClosest Farthest: " + (Double)((ArrayList)results[i]).get(maxIndex) + " <= " + minmaxdis + "\n");
                if ((Double)((ArrayList)results[i]).get(maxIndex) < minmaxdis)
                {
                    standardOutput<-print("\t\tClearing\n");
                    for(int j = 0; j < 6; j++)
                    {
                        idealHubStar[j].clear();
                    }
                }

				minmaxdis = (Double)((ArrayList)results[i]).get(maxIndex);
				idealHubStar[0].add((Double)((ArrayList)results[i]).get(xIndex));
				idealHubStar[1].add((Double)((ArrayList)results[i]).get(yIndex));
				idealHubStar[2].add((Double)((ArrayList)results[i]).get(zIndex));
				idealHubStar[3].add((Double)((ArrayList)results[i]).get(xMaxIndex));//hold on
				idealHubStar[4].add((Double)((ArrayList)results[i]).get(yMaxIndex));//hold on
				idealHubStar[5].add((Double)((ArrayList)results[i]).get(zMaxIndex));//hold on
			}

			if ((Double)((ArrayList)results[i]).get(minIndex) >= maxmindis)
            {
                standardOutput<-print("\t\t\tFarthest Closest: " + (Double)((ArrayList)results[i]).get(minIndex) + " >= " + maxmindis + "\n");
                if ((Double)((ArrayList)results[i]).get(minIndex) > maxmindis)
                {
                    standardOutput<-print("\t\t\tClearing\n");
                    for (int j = 0; j < 6; j++)
                    {
                        idealJailStar[j].clear();
                    }
                }

				maxmindis = (Double)((ArrayList)results[i]).get(minIndex);
				idealJailStar[0].add((Double)((ArrayList)results[i]).get(xIndex));
				idealJailStar[1].add((Double)((ArrayList)results[i]).get(yIndex));
				idealJailStar[2].add((Double)((ArrayList)results[i]).get(zIndex));
				idealJailStar[3].add((Double)((ArrayList)results[i]).get(xMinIndex));//hold on
				idealJailStar[4].add((Double)((ArrayList)results[i]).get(yMinIndex));//hold on
				idealJailStar[5].add((Double)((ArrayList)results[i]).get(zMinIndex));//hold on
			}

			if ((Double)((ArrayList)results[i]).get(avgIndex) <= minavgdis)
            {
                standardOutput<-print("\t\t\t\tMinimum Average: " + (Double)((ArrayList)results[i]).get(avgIndex) + " <= " + minavgdis + "\n");
                if ((Double)((ArrayList)results[i]).get(avgIndex) < minavgdis)
                {
                    standardOutput<-print("\t\t\t\tClearing\n");
                    for (int j = 0; j < 3; j++)
                    {
                        idealCapitalStar[j].clear();
                    }
                }
				minavgdis = (Double)((ArrayList)results[i]).get(avgIndex);
				idealCapitalStar[0].add((Double)((ArrayList)results[i]).get(xIndex));
				idealCapitalStar[1].add((Double)((ArrayList)results[i]).get(yIndex));
				idealCapitalStar[2].add((Double)((ArrayList)results[i]).get(zIndex));
			}
		}

		token cndedup = dedupPair(closestNeighbor);
		token fndedup = dedupPair(farthestNeighbor);

        long result = System.currentTimeMillis() - startTime;

		standardOutput<-println("Stars file: "+starsFile+"\nnumber of stars: "+numStar+"\n\nminimal pairwise distance: "+closestNeighborDist)@
		outputArrayList(cndedup)@
		standardOutput<-println(token)@
		standardOutput<-println("maximal pairwise distance: "+farthestNeighborDist)@
		outputArrayList(fndedup)@
		standardOutput<-println(token)@
		standardOutput<-println("minimum maximal distance: "+minmaxdis)@
		outputArrayList(idealHubStar)@
		standardOutput<-println(token)@
		standardOutput<-println("maximum minimal distance: "+maxmindis)@
		outputArrayList(idealJailStar)@
		standardOutput<-println(token)@
		standardOutput<-println("minimal average distance: "+minavgdis)@
		outputArrayList(idealCapitalStar)@
		standardOutput<-println(token)@
        standardOutput<-print("Total time: " + result + " ms.\n");

	}

	ArrayList[] dedupPair(ArrayList[] pairs) {
		for (int i = 1; i < pairs[0].size(); ) {
			boolean removed = false;
			for (int j = 0; j < i; j++) {
				double i0 = (Double)pairs[0].get(i);
				double i1 = (Double)pairs[1].get(i);
				double i2 = (Double)pairs[2].get(i);
				double i3 = (Double)pairs[3].get(i);
				double i4 = (Double)pairs[4].get(i);
				double i5 = (Double)pairs[5].get(i);
				double j0 = (Double)pairs[0].get(j);
				double j1 = (Double)pairs[1].get(j);
				double j2 = (Double)pairs[2].get(j);
				double j3 = (Double)pairs[3].get(j);
				double j4 = (Double)pairs[4].get(j);
				double j5 = (Double)pairs[5].get(j);
				if (i0 == j3 && i1 == j4 && i2 == j5 && i3 == j0 && i4 == j1 && i5 == j2) {
					for (int k = 0; k < 6; k++) pairs[k].remove(i);
					removed = true;
					break;
				}
			}
			if (!removed) i++;
		}
		return pairs;
	}

	String outputArrayList(ArrayList[] list) {
		join {
			for (int i = 0; i < list[0].size(); i++) outputColumn(list, i);
		}@concat(token)@currentContinuation;
	}

	String concat(Object[] strings) {
		String ret = "";
		for (int i = 0; i < strings.length; i++) ret += (String)strings[i]+"\n";
		return ret;
	}

	String outputColumn(ArrayList[] list, int col) {
		String ret = "<";
		for (int i = 0; i < list.length; i++) {
			ret += list[i].get(col);
			if (i == list.length-1) ret += ">";
			else if (i%3 == 2) ret += "> <";
			else ret += ",";
		}
		return ret;
	}
}
