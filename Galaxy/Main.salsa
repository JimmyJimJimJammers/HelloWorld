module Galaxy;

import java.io.*;
import java.util.*;

/* Analyzer.salsa -- Parallel distance calculation rules
 *
 * Input: 
 *    1.  starsFile.txt, a stars text file with the first line giving the total number of stars in the file 
 *        followed by one line per star representing each star's three dimensions <x,y,z> as X Y Z. 
 *    2.  n, number of Actresses.
 *    3.  serverName, the name server
 *    4.  theatersFile.txt, a file containing theater locations
 *
 * Output:  
 *    1.  Closest neighbours, the set of pairs of stars that minimize pairwise distance.
 *    2.  Farthest neighbours, the set of pairs of stars that maximize pairwise distance.
 *    3.  Ideal hub stars, the set of stars which minimize the maximal distance to any other star.
 *    4.  Ideal jail stars, the set of stars which maximize the minimal distance to any other star.
 *    5.  Ideal capital stars, the set of stars which minimize the average distance to all other stars.
 *
 * Algorithm:
 *    1.  
 *    2.  
 *    3a. 
 *    3b. 
 *
 * Note:  
 *
 */

behavior Main 
{
	String starsFile = "test.txt";    // Stars file
	long startTime = 0;                 // Starting Time
	String serverName = "localhost";  // Name Server
	String theatersFile = "theatersFile.txt";    // File containing the theaters          
	int numStars;                        // number of different stars
	double[][] starPoints;


	// Change these into map form
	// use strings for keys 
	int xIndex = 0;
    int yIndex = 1;
    int zIndex = 2;
    int minIndex = 3;
    int maxIndex = 4;
    int xMinIndex = 5;
    int yMinIndex = 6;
    int zMinIndex = 7;
    int xMaxIndex = 8;
    int yMaxIndex = 9;
    int zMaxIndex = 10;
    int avgIndex = 11;
    int numStarsIndex = 12; // used to encode the result of one actor with an array of doubles

	void act(String [] argv)
	{
			
		if (argv[argv.length-1].equalsIgnoreCase("-c"))
		{
			standardOutput<-print("WE Made it!");
			starsFile = argv[0];
            removeDuplicates()@SendtoActressesC();
		}
		else 
		{
			if (argv.length == 3) 
			{
				starsFile = argv[0];
				serverName = argv[1];
				theatersFile = argv[2];
			}
			removeDuplicates()@SendtoActresses();
		}
	}

	/** Deduplicate the stars file, return the name of the deduplicated file */
		void removeDuplicates()
		{

			TreeSet starSet = new TreeSet();
			try 
			{

				BufferedReader bufferedReader = new BufferedReader(new FileReader(starsFile));
				String tempStar;
	            tempStar = bufferedReader.readLine();
	            numStars = Integer.parseInt(tempStar);
	            starPoints = new double[numStars][3];
	            int i=0;
				while ((tempStar = bufferedReader.readLine()) != null)
				{
					if (!tempStar.equalsIgnoreCase("")) 
					{
						starSet.add(tempStar);
						//standardOutput<-println(">> " + tempStar);

						String[] parts = tempStar.split(" ");
	                	if(parts.length > 1)
	                	{
	                    starPoints[i][0] = Double.parseDouble(parts[0]);
	                    starPoints[i][1] = Double.parseDouble(parts[1]);
	                    starPoints[i][2] = Double.parseDouble(parts[2]);
	               		}
					}
					i++;
				}

				bufferedReader.close();
			} 
			catch (IOException ioe) 
			{
				standardOutput<-print("File Error: " + starsFile + "\n");
			}

		}

	/** Distribute to the Actresses based on the deduplicated stars file for distributed computation */
	void SendtoActresses() {

		//create Actresses and assign data
		Actress[] Actresses = new Actress[numStars];
		ArrayList theaters = new ArrayList();
		String theater;
		int i = 0;
		while( i < numStars)
		{                                   	// first create actresses
			Actresses[i] = new Actress();
			i++;
		}


		try {															// try to find theaters
			BufferedReader bufferedReader = new BufferedReader(new FileReader(theatersFile));
			while ((theater = bufferedReader.readLine()) != null) {
				theaters.add(theater);
			}
			bufferedReader.close(); 
		} catch (IOException ioe){
			standardOutput<-println("File Error: " + theatersFile);
		}

		// migrate Actresses to theaters
		int looper = 0;                                    // ************************COME BACK TO HERE *********************
		int x = 0;
		while (looper < numStars)
		{
			if (x == theaters.size())
				x = 0;
			standardOutput<-print("Sending Actress uan://" + serverName + ":3030/a"+ x +" to rmsp://" +theaters.get(x)+"/a"+x + "\n");

			Actresses[x] = new Actress() at  (new UAN("uan://"+serverName+":3030/a"+x), new UAL("rmsp://"+theaters.get(x)+"/a"+x));
			x++;
		}
		
		standardOutput<-print("Program Start: \n");
		startTime = System.currentTimeMillis();
		
		//start computation using join method
		join 
		{
			int t =0;
			while(t < numStars)
			 {
				Actresses[t]<-calc(t, starPoints, numStars);
				t++;
			}
		}@compareData(token);
	}

	//Concurrent version
	void SendtoActressesC() {

		//create Actresses and assign data
		Actress[] Actresses = new Actress[numStars];
		int t =0;
		while (t < numStars)
		{                                
			Actresses[t] = new Actress();
			t++;
		}

		
		startTime = System.currentTimeMillis();
		standardOutput<-print("Program Start: \n");	

		join 																// Starting the computation
		{
			int x = 0;
			while(x < numStars)
			{
				Actresses[x]<-calc(x, starPoints, numStars);
				x++;
			}
		}@compareData(token);
	}

	void endTimer(){
		long endTime = System.currentTimeMillis();
		long result = endTime - startTime;
		standardOutput<-print("Total time: " + result +" ms.\n");
	}

    //takes the actressOutput from the Actresses and combines them
	void compareData(Object[] actressOutput)
    {
        //closest neighbours
		double closestNeighborDist = Double.MAX_VALUE;
        //farthest neighbours
        double farthestNeighborDist = 0.0;
        //minimum max distance **
        double minFarthestStar = Double.MAX_VALUE;
        //maximum min distance **
        double maxClosestStar = 0.0;
        // minimum average distance
        double minAverageDist = Double.MAX_VALUE;

        //for holding the each star and it's closest neighbor
		ArrayList[] closestNeighbor = new ArrayList[6];             //pair
        // farthest neighbour pairs
        ArrayList[] farthestNeighbor = new ArrayList[6];            //pair
        //ideal hub stars
        ArrayList[] idealHubStar = new ArrayList[6];                //single
        // ideal jail stars
        ArrayList[] idealJailStar = new ArrayList[6];               //single
        // ideal capital stars
        ArrayList[] idealCapitalStar = new ArrayList[3];            //single

        //go through and make an ArrayList for each coordinate?
		for (int i = 0; i < 6; i++)
        {
            closestNeighbor[i] = new ArrayList();
            farthestNeighbor[i] = new ArrayList();
            idealHubStar[i] = new ArrayList();
            idealJailStar[i] = new ArrayList();

            if(i < 3)
            {
                idealCapitalStar[i] = new ArrayList();
            }

        }

		//standardOutput<-println("summing...");
		for (int i = 0; i < numStars; i++)
        {
            //if the closest neighbors for this pair is closer, update the value
			if ((Double)((ArrayList)actressOutput[i]).get(minIndex) <= closestNeighborDist)
            {
                standardOutput<-print("Closest Dist: " + (Double)((ArrayList)actressOutput[i]).get(minIndex) + " <= " + closestNeighborDist + "\n");
                if((Double)((ArrayList)actressOutput[i]).get(minIndex) < closestNeighborDist)
                {
                    standardOutput<-print("Clearing\n");
                    for (int j = 0; j < 6; j++)
                    {
                        closestNeighbor[j].clear();
                    }
                }

				closestNeighborDist = (Double)((ArrayList)actressOutput[i]).get(minIndex);
				closestNeighbor[0].add((Double)((ArrayList)actressOutput[i]).get(xIndex));
				closestNeighbor[1].add((Double)((ArrayList)actressOutput[i]).get(yIndex));
				closestNeighbor[2].add((Double)((ArrayList)actressOutput[i]).get(zIndex));
				closestNeighbor[3].add((Double)((ArrayList)actressOutput[i]).get(xMinIndex));
				closestNeighbor[4].add((Double)((ArrayList)actressOutput[i]).get(yMinIndex));
				closestNeighbor[5].add((Double)((ArrayList)actressOutput[i]).get(zMinIndex));
			}

			if ((Double)((ArrayList)actressOutput[i]).get(maxIndex) >= farthestNeighborDist)
            {
                standardOutput<-print("\tFarthest Dist: " + (Double)((ArrayList)actressOutput[i]).get(maxIndex) + " >= " + farthestNeighborDist + "\n");
                if((Double)((ArrayList)actressOutput[i]).get(maxIndex) > farthestNeighborDist)
                {
                    standardOutput<-print("\tClearing\n");
                    for (int j = 0; j < 6; j++)
                    {
                        farthestNeighbor[j].clear();
                    }
                }

				farthestNeighborDist = (Double)((ArrayList)actressOutput[i]).get(maxIndex);
				farthestNeighbor[0].add((Double)((ArrayList)actressOutput[i]).get(xIndex));
				farthestNeighbor[1].add((Double)((ArrayList)actressOutput[i]).get(yIndex));
				farthestNeighbor[2].add((Double)((ArrayList)actressOutput[i]).get(zIndex));
				farthestNeighbor[3].add((Double)((ArrayList)actressOutput[i]).get(xMaxIndex));
				farthestNeighbor[4].add((Double)((ArrayList)actressOutput[i]).get(yMaxIndex));
				farthestNeighbor[5].add((Double)((ArrayList)actressOutput[i]).get(zMaxIndex));
			}

			if ((Double)((ArrayList)actressOutput[i]).get(maxIndex) <= minFarthestStar)
            {
                standardOutput<-print("\t\tClosest Farthest: " + (Double)((ArrayList)actressOutput[i]).get(maxIndex) + " <= " + minFarthestStar + "\n");
                if ((Double)((ArrayList)actressOutput[i]).get(maxIndex) < minFarthestStar)
                {
                    standardOutput<-print("\t\tClearing\n");
                    for(int j = 0; j < 6; j++)
                    {
                        idealHubStar[j].clear();
                    }
                }

				minFarthestStar = (Double)((ArrayList)actressOutput[i]).get(maxIndex);
				idealHubStar[0].add((Double)((ArrayList)actressOutput[i]).get(xIndex));
				idealHubStar[1].add((Double)((ArrayList)actressOutput[i]).get(yIndex));
				idealHubStar[2].add((Double)((ArrayList)actressOutput[i]).get(zIndex));
				idealHubStar[3].add((Double)((ArrayList)actressOutput[i]).get(xMaxIndex));//hold on
				idealHubStar[4].add((Double)((ArrayList)actressOutput[i]).get(yMaxIndex));//hold on
				idealHubStar[5].add((Double)((ArrayList)actressOutput[i]).get(zMaxIndex));//hold on
			}

			if ((Double)((ArrayList)actressOutput[i]).get(minIndex) >= maxClosestStar)
            {
                standardOutput<-print("\t\t\tFarthest Closest: " + (Double)((ArrayList)actressOutput[i]).get(minIndex) + " >= " + maxClosestStar + "\n");
                if ((Double)((ArrayList)actressOutput[i]).get(minIndex) > maxClosestStar)
                {
                    standardOutput<-print("\t\t\tClearing\n");
                    for (int j = 0; j < 6; j++)
                    {
                        idealJailStar[j].clear();
                    }
                }

				maxClosestStar = (Double)((ArrayList)actressOutput[i]).get(minIndex);
				idealJailStar[0].add((Double)((ArrayList)actressOutput[i]).get(xIndex));
				idealJailStar[1].add((Double)((ArrayList)actressOutput[i]).get(yIndex));
				idealJailStar[2].add((Double)((ArrayList)actressOutput[i]).get(zIndex));
				idealJailStar[3].add((Double)((ArrayList)actressOutput[i]).get(xMinIndex));//hold on
				idealJailStar[4].add((Double)((ArrayList)actressOutput[i]).get(yMinIndex));//hold on
				idealJailStar[5].add((Double)((ArrayList)actressOutput[i]).get(zMinIndex));//hold on
			}

			if ((Double)((ArrayList)actressOutput[i]).get(avgIndex) <= minAverageDist)
            {
                standardOutput<-print("\t\t\t\tMinimum Average: " + (Double)((ArrayList)actressOutput[i]).get(avgIndex) + " <= " + minAverageDist + "\n");
                if ((Double)((ArrayList)actressOutput[i]).get(avgIndex) < minAverageDist)
                {
                    standardOutput<-print("\t\t\t\tClearing\n");
                    for (int j = 0; j < 3; j++)
                    {
                        idealCapitalStar[j].clear();
                    }
                }
				minAverageDist = (Double)((ArrayList)actressOutput[i]).get(avgIndex);
				idealCapitalStar[0].add((Double)((ArrayList)actressOutput[i]).get(xIndex));
				idealCapitalStar[1].add((Double)((ArrayList)actressOutput[i]).get(yIndex));
				idealCapitalStar[2].add((Double)((ArrayList)actressOutput[i]).get(zIndex));
			}
		}

		token closestNeighborDup = dedupPair(closestNeighbor);
		token farthestNeighborDup = dedupPair(farthestNeighbor);

        long result = System.currentTimeMillis() - startTime;

/*
 d1  // minimal pairwise distance
 s1 s2
 ...
 
 d2  // maximal pairwise distance
 s1 s2
 s3 s2
 ...
 
 d3 // minimum maximal distance
 s3 s1
 ...
 
 d4 // maximum minimal distance
 s4
 s5
 ...
 
 d5 // minimal average distance
 s1
 ...
 where d_i denotes a distance and s_i denotes a star, which is represented as (x,y,z), corresponding to the x, y, and z coordinates of the star.
 */
        standardOutput<-print("\nClosest Neighbor Distance: " + closestNeighborDist + "\n") @
        printAllElements(closestNeighbor, 6) @
        standardOutput<-println("Farthest Neighbor Distance: " + farthestNeighborDist) @
        printAllElements(farthestNeighbor, 6) @
        standardOutput<-println("Minimum Farthest Star Distance: " + minFarthestStar) @
        printAllElements(idealHubStar, 3) @
        standardOutput<-println("Maximum Closest Star Distance: " + maxClosestStar) @
        printAllElements(idealJailStar, 3) @
        standardOutput<-println("Minimum Average Distance: " + minAverageDist) @
        printAllElements(idealCapitalStar, 3) @
        standardOutput<-print("Completion Time: " + result + " ms.\n");

	}

    void printAllElements(ArrayList[] outputStuff, int arraySize)
    {
        for(int i = 0; i < outputStuff[0].size(); i++)
        {
            standardOutput<-print("\t(");
            for(int j = 0; j < arraySize; j++)
            {
                if(j == 3)
                {
                    standardOutput<-print("(");
                }
                double temp = (Double)outputStuff[j].get(i);
                if((j+1)%3 != 0)
                {
                    standardOutput<-print(temp + ", ");
                }
                else
                {
                    standardOutput<-print(temp + ")");
                }
            }
            standardOutput<-print("\n");
        }

        //currentContinuation;
    }


	ArrayList[] dedupPair(ArrayList[] pairs) {
		for (int i = 1; i < pairs[0].size(); ) {
			boolean removed = false;
			for (int j = 0; j < i; j++) {
				double i0 = (Double)pairs[0].get(i);
				double i1 = (Double)pairs[1].get(i);
				double i2 = (Double)pairs[2].get(i);
				double i3 = (Double)pairs[3].get(i);
				double i4 = (Double)pairs[4].get(i);
				double i5 = (Double)pairs[5].get(i);
				double j0 = (Double)pairs[0].get(j);
				double j1 = (Double)pairs[1].get(j);
				double j2 = (Double)pairs[2].get(j);
				double j3 = (Double)pairs[3].get(j);
				double j4 = (Double)pairs[4].get(j);
				double j5 = (Double)pairs[5].get(j);
				if (i0 == j3 && i1 == j4 && i2 == j5 && i3 == j0 && i4 == j1 && i5 == j2) {
					for (int k = 0; k < 6; k++) pairs[k].remove(i);
					removed = true;
					break;
				}
			}
			if (!removed) i++;
		}
		return pairs;
	}
}
