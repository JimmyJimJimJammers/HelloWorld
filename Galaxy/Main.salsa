module Galaxy;

import java.io.*;
import java.util.*;

/* Analyzer.salsa -- Parallel distance calculation rules
 *
 * Input: 
 *    1.  starsFile.txt, a stars text file with the first line giving the total number of stars in the file 
 *        followed by one line per star representing each star's three dimensions <x,y,z> as X Y Z. 
 *    2.  n, number of Actresses.
 *    3.  serverName, the name server
 *    4.  theatersFile.txt, a file containing theater locations
 *
 * Output:  
 *    1.  Closest neighbours, the set of pairs of stars that minimize pairwise distance.
 *    2.  Farthest neighbours, the set of pairs of stars that maximize pairwise distance.
 *    3.  Ideal hub stars, the set of stars which minimize the maximal distance to any other star.
 *    4.  Ideal jail stars, the set of stars which maximize the minimal distance to any other star.
 *    5.  Ideal capital stars, the set of stars which minimize the average distance to all other stars.
 *
 * Algorithm:
 *    1.  
 *    2.  
 *    3a. 
 *    3b. 
 *
 * Note:  
 *
 */

behavior Main 
{
	String starsFile = "test.txt";    // Stars file
	long startTime = 0;                 // Starting Time
	String serverName = "localhost";  // Name Server
	String theatersFile = "theatersFile.txt";    // File containing the theaters          
	String newFile = "newFile.txt";
	int numStar;                        // number of different stars


	// Change these into map form
	// use strings for keys 
	int X = 0;
    int Y = 1;
    int Z = 2;
    int MIN = 3;
    int MAX = 4;
    int XMIN = 5;
    int YMIN = 6;
    int ZMIN = 7;
    int XMAX = 8;
    int YMAX = 9;
    int ZMAX = 10;
    int AVG = 11;
    int RESULTSIZE = 12; // used to encode the result of one actor with an array of doubles

	void act(String [] argv)
	{
			
		if (argv[argv.length-1].equalsIgnoreCase("-c"))
		{
			standardOutput<-print("WE Made it!");
			starsFile = argv[0];
            removeDuplicates()@SendtoActressesC();
		}
		else 
		{
			if (argv.length == 3) 
			{
				starsFile = argv[0];
				serverName = argv[1];
				theatersFile = argv[2];
			}
			removeDuplicates()@SendtoActresses();
		}
	}


	/** Deduplicate the stars file, return the name of the deduplicated file */
	void removeDuplicates()
	{

		TreeSet starSet = new TreeSet();
		try 
		{

			BufferedReader bufferedReader = new BufferedReader(new FileReader(starsFile));
			String tempStar;
            tempStar = bufferedReader.readLine();

			while ((tempStar = bufferedReader.readLine()) != null) 
				if (!tempStar.equalsIgnoreCase("")) 
					starSet.add(tempStar);
			bufferedReader.close();
		} 
		catch (IOException ioe) 
		{
			standardOutput<-print("File Error: " + starsFile + "\n");
		}

		try 
		{
			PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(newFile)));
			Iterator itr = starSet.iterator(); 
			while(itr.hasNext()) 
				writer.println((String)itr.next());
			writer.close();
		} 
		catch (IOException ioe) 
		{
			standardOutput<-print("File Error: " + newFile + "\n");
		}
		numStar = starSet.size();
	}

	/** Distribute to the Actresses based on the deduplicated stars file for distributed computation */
	void SendtoActresses() {

		//create Actresses and assign data
		Actress[] Actresses = new Actress[numStar];
		ArrayList theaters = new ArrayList();
		String theater;
		int i = 0;
		while( i < numStar)
		{                                   	// first create actresses
			Actresses[i] = new Actress();
			i++;
		}


		try {															// try to find theaters
			BufferedReader bufferedReader = new BufferedReader(new FileReader(theatersFile));
			while ((theater = bufferedReader.readLine()) != null) {
				theaters.add(theater);
			}
			bufferedReader.close(); 
		} catch (IOException ioe){
			standardOutput<-println("File Error: " + theatersFile);
		}

		// migrate Actresses to theaters
		int looper = 0;                                    // ************************COME BACK TO HERE *********************
		int x = 0;
		while (looper < numStar)
		{
			if (x == theaters.size())
				x = 0;
			standardOutput<-print("Sending Actress uan://" + serverName + ":3030/a"+ x +" to rmsp://" +theaters.get(x)+"/a"+x + "\n");

			Actresses[x] = new Actress() at  (new UAN("uan://"+serverName+":3030/a"+x), new UAL("rmsp://"+theaters.get(x)+"/a"+x));
			x++;
		}
		
		standardOutput<-print("Program Start: \n");
		startTime = System.currentTimeMillis();
		
		//start computation using join method
		join 
		{
			int t =0;
			while(t < numStar)
			 {
				Actresses[t]<-calc(t, newFile, numStar);
				t++;
			}
		}@summarize(token);
	}

	//Concurrent version
	void SendtoActressesC() {

		//create Actresses and assign data
		Actress[] Actresses = new Actress[numStar];
		int t =0;
		while (t < numStar)
		{                                
			Actresses[t] = new Actress();
			t++;
		}

		
		startTime = System.currentTimeMillis();
		standardOutput<-print("Program Start: \n");	

		join 																// Starting the computation
		{
			int x = 0;
			while(x < numStar)
			{
				Actresses[x]<-calc(x, newFile, numStar);
				x++;
			}
		}@summarize(token);
	}

	void endTimer(){
		long endTime = System.currentTimeMillis();
		long result = endTime - startTime;
		standardOutput<-print("Total time: " + result +" ms.\n");
	}

	void summarize(Object[] results) {

		double cndis = Double.MAX_VALUE; // closest neighbour distance
		ArrayList[] cn = new ArrayList[6]; // closest neighbour pairs
		for (int i = 0; i < 6; i++) cn[i] = new ArrayList();
		double fndis = 0.0; // farthest neighbour distance
		ArrayList[] fn = new ArrayList[6]; // farthest neighbour pairs
		for (int i = 0; i < 6; i++) fn[i] = new ArrayList();
		double minmaxdis = Double.MAX_VALUE; // minimum max distance
		ArrayList[] ihs = new ArrayList[6]; // ideal hub stars
		for (int i = 0; i < 6; i++) ihs[i] = new ArrayList();
		double maxmindis = 0.0; // maximum min distance
		ArrayList[] ijs = new ArrayList[6]; // ideal jail stars
		for (int i = 0; i < 6; i++) ijs[i] = new ArrayList();
		double minavgdis = Double.MAX_VALUE; // minimum average distance
		ArrayList[] ics = new ArrayList[3]; // ideal capital stars
		for (int i = 0; i < 3; i++) ics[i] = new ArrayList();

		//standardOutput<-println("summing...");
		for (int i = 0; i < numStar; i++){
			double rmin = (Double)((ArrayList)results[i]).get(MIN);
			double rmax = (Double)((ArrayList)results[i]).get(MAX);
			double ravg = (Double)((ArrayList)results[i]).get(AVG);
			double rx = (Double)((ArrayList)results[i]).get(X);
			double ry = (Double)((ArrayList)results[i]).get(Y);
			double rz = (Double)((ArrayList)results[i]).get(Z);
			double rxmin = (Double)((ArrayList)results[i]).get(XMIN);
			double rymin = (Double)((ArrayList)results[i]).get(YMIN);
			double rzmin = (Double)((ArrayList)results[i]).get(ZMIN);
			double rxmax = (Double)((ArrayList)results[i]).get(XMAX);
			double rymax = (Double)((ArrayList)results[i]).get(YMAX);
			double rzmax = (Double)((ArrayList)results[i]).get(ZMAX);
			//standardOutput<-println(rmin+" "+rmax+" "+ravg+" "+rx+" "+ry+" "+rz);

			if (rmin < cndis) {
				cndis = rmin;
				for (int j = 0; j < 6; j++) cn[j].clear();
				cn[0].add(rx);
				cn[1].add(ry);
				cn[2].add(rz);
				cn[3].add(rxmin);
				cn[4].add(rymin);
				cn[5].add(rzmin);
			} else if (rmin == cndis) {
				cn[0].add(rx);
				cn[1].add(ry);
				cn[2].add(rz);
				cn[3].add(rxmin);
				cn[4].add(rymin);
				cn[5].add(rzmin);
			}

			if (rmax > fndis) {
				fndis = rmax;
				for (int j = 0; j < 6; j++) fn[j].clear();
				fn[0].add(rx);
				fn[1].add(ry);
				fn[2].add(rz);
				fn[3].add(rxmax);
				fn[4].add(rymax);
				fn[5].add(rzmax);
			} else if (rmax == fndis) {
				fn[0].add(rx);
				fn[1].add(ry);
				fn[2].add(rz);
				fn[3].add(rxmax);
				fn[4].add(rymax);
				fn[5].add(rzmax);
			}

			if (rmax < minmaxdis) {
				minmaxdis = rmax;
				for (int j = 0; j < 6; j++) ihs[j].clear();
				ihs[0].add(rx);
				ihs[1].add(ry);
				ihs[2].add(rz);
				ihs[3].add(rxmax);
				ihs[4].add(rymax);
				ihs[5].add(rzmax);
			} else if (rmax == minmaxdis) {
				ihs[0].add(rx);
				ihs[1].add(ry);
				ihs[2].add(rz);
				ihs[3].add(rxmax);
				ihs[4].add(rymax);
				ihs[5].add(rzmax);
			}

			if (rmin > maxmindis) {
				maxmindis = rmin;
				for (int j = 0; j < 6; j++) ijs[j].clear();
				ijs[0].add(rx);
				ijs[1].add(ry);
				ijs[2].add(rz);
				ijs[3].add(rxmin);
				ijs[4].add(rymin);
				ijs[5].add(rzmin);
			} else if (rmin == maxmindis) {
				ijs[0].add(rx);
				ijs[1].add(ry);
				ijs[2].add(rz);
				ijs[3].add(rxmin);
				ijs[4].add(rymin);
				ijs[5].add(rzmin);
			}

			if (ravg < minavgdis) {
				minavgdis = ravg;
				for (int j = 0; j < 3; j++) ics[j].clear();
				ics[0].add(rx);
				ics[1].add(ry);
				ics[2].add(rz);
			} else if (ravg == minavgdis) {
				ics[0].add(rx);
				ics[1].add(ry);
				ics[2].add(rz);
			}
		}

		token cndedup = dedupPair(cn);
		token fndedup = dedupPair(fn);

		standardOutput<-println("Stars file: "+starsFile+"\nnumber of stars: "+numStar+"\n\nminimal pairwise distance: "+cndis)@
		outputArrayList(cndedup)@
		standardOutput<-println(token)@
		standardOutput<-println("maximal pairwise distance: "+fndis)@
		outputArrayList(fndedup)@
		standardOutput<-println(token)@
		standardOutput<-println("minimum maximal distance: "+minmaxdis)@
		outputArrayList(ihs)@
		standardOutput<-println(token)@
		standardOutput<-println("maximum minimal distance: "+maxmindis)@
		outputArrayList(ijs)@
		standardOutput<-println(token)@
		standardOutput<-println("minimal average distance: "+minavgdis)@
		outputArrayList(ics)@
		standardOutput<-println(token)@
		endTimer();
	}

	ArrayList[] dedupPair(ArrayList[] pairs) {
		for (int i = 1; i < pairs[0].size(); ) {
			boolean removed = false;
			for (int j = 0; j < i; j++) {
				double i0 = (Double)pairs[0].get(i);
				double i1 = (Double)pairs[1].get(i);
				double i2 = (Double)pairs[2].get(i);
				double i3 = (Double)pairs[3].get(i);
				double i4 = (Double)pairs[4].get(i);
				double i5 = (Double)pairs[5].get(i);
				double j0 = (Double)pairs[0].get(j);
				double j1 = (Double)pairs[1].get(j);
				double j2 = (Double)pairs[2].get(j);
				double j3 = (Double)pairs[3].get(j);
				double j4 = (Double)pairs[4].get(j);
				double j5 = (Double)pairs[5].get(j);
				if (i0 == j3 && i1 == j4 && i2 == j5 && i3 == j0 && i4 == j1 && i5 == j2) {
					for (int k = 0; k < 6; k++) pairs[k].remove(i);
					removed = true;
					break;
				}
			}
			if (!removed) i++;
		}
		return pairs;
	}

	String outputArrayList(ArrayList[] list) {
		join {
			for (int i = 0; i < list[0].size(); i++) outputColumn(list, i);
		}@concat(token)@currentContinuation;
	}

	String concat(Object[] strings) {
		String ret = "";
		for (int i = 0; i < strings.length; i++) ret += (String)strings[i]+"\n";
		return ret;
	}

	String outputColumn(ArrayList[] list, int col) {
		String ret = "<";
		for (int i = 0; i < list.length; i++) {
			ret += list[i].get(col);
			if (i == list.length-1) ret += ">";
			else if (i%3 == 2) ret += "> <";
			else ret += ",";
		}
		return ret;
	}
}
