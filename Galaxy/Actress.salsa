module Galaxy;
import java.io.*;
import java.util.*;

// this handles all of the parallelization
behavior Actress
{
    //the location of this Actresss star
	double x = 0.0;
	double y = 0.0;
	double z = 0.0;

    //these are the index locations of these values in the array R
    int X = 0;
    int Y = 1;
    int Z = 2;
    int MIN = 3;
    int MAX = 4;
    int XMIN = 5;
    int YMIN = 6;
    int ZMIN = 7;
    int XMAX = 8;
    int YMAX = 9;
    int ZMAX = 10;
    int AVG = 11;
    int RESULTSIZE = 12; // used to encode the result of one worker with an array of doubles

	//take the nth star (using the processed file of stars) and find all of the requested values
	ArrayList calc(int n, String fileProcessed, int numStar)
    {
		double[][] starPoints = new double[numStar][3];

		try
        {
            //get the file that has all the non-duplicate stars
			BufferedReader inputFile = new BufferedReader(new FileReader(fileProcessed));

            //go through every line and gather star locations
			for (int i = 0; i < numStar; i++)
            {
				String stringPoints = inputFile.readLine();
				String[] parts = stringPoints.split(" ");
                if(parts.length > 1)
                {
                    starPoints[i][0] = Double.parseDouble(parts[0]);
                    starPoints[i][1] = Double.parseDouble(parts[1]);
                    starPoints[i][2] = Double.parseDouble(parts[2]);
                }
			}
			inputFile.close();
		}
        catch (IOException ioe)
        {
			standardOutput<-println("[error] Can't open the file " + fileProcessed + " for reading.");
		}

        //get the locations values of the star we are currently interested in
		x = starPoints[n][0];
		y = starPoints[n][1];
		z = starPoints[n][2];


		getMinMax(n, starPoints)@currentContinuation;
		/*
			 token t = getMinMax(n, starPoints);
			 displayResult(t)@
			 returnSelf(t)@currentContinuation;
			 */
	}

	/** get the minimum distance and the maximum distance and the average distance from the n-th star to all the other stars */
	ArrayList getMinMax(int n, double[][] starPoints)
    {
        //make a new list of the values we are interested in
		double[] returnValues = new double[RESULTSIZE];

        //initialize values to current star location
		returnValues[X] = returnValues[XMIN] = returnValues[XMAX] = x;
		returnValues[Y] = returnValues[YMIN] = returnValues[YMAX] = y;
		returnValues[Z] = returnValues[ZMIN] = returnValues[ZMAX] = z;
		returnValues[MIN] = Double.MAX_VALUE;
		returnValues[MAX] = 0.0;
		returnValues[AVG] = 0.0;


        //calculate the min and max to the first star in the list
        //token tokenReturnValues = findMinMaxAvg1(returnValues, starPoints[0]);
        for (int i = 0; i < starPoints.length; i++) if (i != n)
        {
            //calculate the min and max to the rest of the stars in the list
            //tokenReturnValues = findMinMaxAvg1(tokenReturnValues, starPoints[i]);

            //get the difference between this current star and the star passed to the method
            double dx = x-starPoints[i][0];
            double dy = y-starPoints[i][1];
            double dz = z-starPoints[i][2];

            //if that difference is not 0
            if (dx != 0.0 || dy != 0.0 || dz != 0.0)
            {
                //calculate the distance between
                double dis = Math.sqrt(dx*dx+dy*dy+dz*dz);

                //if the distance is smaller than the current minimum then set the new min
                if (dis < returnValues[MIN])
                {
                    returnValues[MIN] = dis;
                    returnValues[XMIN] = starPoints[i][0];
                    returnValues[YMIN] = starPoints[i][1];
                    returnValues[ZMIN] = starPoints[i][2];
                }

                //if the distance is larger than the current maximum then set the new max
                if (dis > returnValues[MAX])
                {
                    returnValues[MAX] = dis;
                    returnValues[XMAX] = starPoints[i][0];
                    returnValues[YMAX] = starPoints[i][1];
                    returnValues[ZMAX] = starPoints[i][2];
                }

                //add the distance to the Average
                returnValues[AVG] += dis;
            }
        }

        //return the results via message
        returnSelf(returnValues)@getAvg(token, starPoints.length)@convert2ArrayList(token)@currentContinuation;

		//findMinMaxAvg(returnValues, n, starPoints)@getAvg(token, starPoints.length)@convert2ArrayList(token)@currentContinuation;
	}

	ArrayList convert2ArrayList(double[] a)
    {
		ArrayList returnValues = new ArrayList();
		for (int i = 0; i < a.length; i++) returnValues.add(a[i]);
		return returnValues;
	}

    double[] returnSelf(double[] returnValues)
    {
        return returnValues;
    }

    //r[AVG] is actually the total for quite a while, this divides it by the total number of stars
    double[] getAvg(double[] returnValues, int tot)
    {
        returnValues[AVG] /= tot;
        return returnValues;
    }


	//goes through each star and looks for min and max distances and stars
	/*double[] findMinMaxAvg(double[] returnValues, int n, double[][] starPoints)
    {

        //calculate the min and max to the first star in the list
		//token tokenReturnValues = findMinMaxAvg1(returnValues, starPoints[0]);

		for (int i = 0; i < starPoints.length; i++) if (i != n)
        {
            //calculate the min and max to the rest of the stars in the list
			//tokenReturnValues = findMinMaxAvg1(tokenReturnValues, starPoints[i]);

            //get the difference between this current star and the star passed to the method
            double dx = x-starPoints[i][0];
            double dy = y-starPoints[i][1];
            double dz = z-starPoints[i][2];

            //if that difference is not 0
            if (dx != 0.0 || dy != 0.0 || dz != 0.0)
            {
                //calculate the distance between
                double dis = Math.sqrt(dx*dx+dy*dy+dz*dz);

                //if the distance is smaller than the current minimum then set the new min
                if (dis < returnValues[MIN])
                {
                    returnValues[MIN] = dis;
                    returnValues[XMIN] = starPoints[i][0];
                    returnValues[YMIN] = starPoints[i][1];
                    returnValues[ZMIN] = starPoints[i][2];
                }

                //if the distance is larger than the current maximum then set the new max
                if (dis > returnValues[MAX])
                {
                    returnValues[MAX] = dis;
                    returnValues[XMAX] = starPoints[i][0];
                    returnValues[YMAX] = starPoints[i][1];
                    returnValues[ZMAX] = starPoints[i][2];
                }

                //add the distance to the Average
                returnValues[AVG] += dis;
            }
		}

        //return the results via message
		returnSelf(returnValues)@currentContinuation;

	}*/

	//this function is necessary because we need it for returning results via the @ notation


    //used to find stats on a single star, but I moved it to the upper method.
	/*double[] findMinMaxAvg1(double[] returnValues, double[] star)
    {
        //get the difference between this current star and the star passed to the method
		double dx = x-star[0];
		double dy = y-star[1];
		double dz = z-star[2];

        //if that difference is not 0
		if (dx != 0.0 || dy != 0.0 || dz != 0.0)
        {
            //calculate the distance between
			double dis = Math.sqrt(dx*dx+dy*dy+dz*dz);

            //if the distance is smaller than the current minimum then set the new min
			if (dis < returnValues[MIN])
            {
				returnValues[MIN] = dis;
				returnValues[XMIN] = star[0];
				returnValues[YMIN] = star[1];
				returnValues[ZMIN] = star[2];
			}

            //if the distance is larger than the current maximum then set the new max
			if (dis > returnValues[MAX])
            {
				returnValues[MAX] = dis;
				returnValues[XMAX] = star[0];
				returnValues[YMAX] = star[1];
				returnValues[ZMAX] = star[2];
			}

            //add the distance to the Average
			returnValues[AVG] += dis;
		}
		return returnValues;
	}*/

	//this is what will run if we compile and run this file alone, it tests whether or not the methods work
	void act(String args[])
    {
		calc(1, "test.txt", 4)@displayResult(token)@
        calc(2, "test.txt", 4)@displayResult(token);
	}

	/** display the content of a Result object */
	ArrayList displayResult(ArrayList returnValues)
    {
		double rmin = (Double)returnValues.get(MIN);
		double rmax = (Double)returnValues.get(MAX);
		double ravg = (Double)returnValues.get(AVG);
		double rx = (Double)returnValues.get(X);
		double ry = (Double)returnValues.get(Y);
		double rz = (Double)returnValues.get(Z);
		double rxmin = (Double)returnValues.get(XMIN);
		double rymin = (Double)returnValues.get(YMIN);
		double rzmin = (Double)returnValues.get(ZMIN);
		double rxmax = (Double)returnValues.get(XMAX);
		double rymax = (Double)returnValues.get(YMAX);
		double rzmax = (Double)returnValues.get(ZMAX);

		standardOutput<-println("\nThe final result for "+rx+" "+ry+" "+rz+" is\nmin distance: "+rmin+"\nfrom "+rxmin+" "+rymin+" "+rzmin+"\nmax distance: "+rmax+"\nfrom "+rxmax+" "+rymax+" "+rzmax+"\navg distance: "+ravg);

		return returnValues;
	}

}

